#!/bin/bash
set -e

###
# doc - Docker Operation Control
###

VERSION=0.6

DOCKER_COMPOSE_LOCAL_FILE="docker-compose.local.yml"
DOCKER_COMPOSE_TEST_FILE="docker-compose.test.yml"
DOCKER_COMPOSE_BETA_FILE="docker-compose.beta.yml"
DOCKER_COMPOSE_PROD_FILE="docker-compose.prod.yml"
DOCKER_COMPOSE_FILE="docker-compose.yml"
DOC_DOCKERFILE_INSTALL="./dockerfiles/Dockerfile-install"
DOC_DOCKERFILE_PROD="./dockerfiles/Dockerfile-prod"
DOC_VHOST_CONFIG="./config/apache-vhost.conf"
DOC_SETTINGS="./config/settings.sh"
SOURCE_DIR="./sources"
NGINX_CONTAINER="nginx"

showhelp() {
	out ""
	out "doc $VERSION"
	out "========================================"
	out "Commands:"
	out "build \t\t\t\t\t - building an image"
	out "tag \t\t\t\t\t - build and tag an image"
	out "up [local|prod] \t\t\t - run docker-compose with given environment"
	out "down \t\t\t\t\t - stop all containers an remove them"
	out "stop \t\t\t\t\t - stop all containers"
	out "in \t\t\t\t\t - search for running web container and open a shell in it"
	out "deploy \t\t\t\t\t - build, tag and deploy to remote repo"
	out "initproject [projectname] [git url] \t - initialize a new project"
	out "logs [web|nginx] \t\t\t - show log output of all or specific container [web, typo3-db, nginx]"
	out "reinit [projectname] \t\t\t - rewrite all Docker- and docker-composer files from templates"
	out "self-update \t\t\t\t - run self update and pull latest version"
	out ""
}

### Docker Commands
dockerdeploy() {
    IMAGE_NAME="$1"
	CUR_VERSION=$(get_current_version $IMAGE_NAME)

	if [ -z "$CUR_VERSION" ]; then
		errout "either current version or image could not be determined"
		exit 1;
	fi

	info "Deploying image $IMAGE_NAME with version $CUR_VERSION to $DOC_REPO...\n"

	#push image to remote docker repo
	docker -D -l=debug push "$DOC_REPO/$IMAGE_NAME"
}

get_current_version() {
	if [ "$1" == '' ]; then
		errout "missing image name"
		exit 1;
	fi
	echo  $(sed -n "s|.*image:\s*\($DOC_REPO/\)\?$1:\(.*\)$|\2|p" "$DOCKER_COMPOSE_FILE")
}

buildandtag() {
	IMAGE_NAME=$1
	CUR_VERSION=$2

	if [ -z "$2" ]; then
		CUR_VERSION=$(get_current_version $IMAGE_NAME)
	fi

	if [ -z "$CUR_VERSION" ]; then
		errout "current version could not be determined fo $IMAGE_NAME"
		exit 1;
	fi

	info "current version is $CUR_VERSION"

	NEW_VERSION=$(increment_version $CUR_VERSION)
	NEW_IMAGE_NAME="$DOC_REPO/$IMAGE_NAME:$NEW_VERSION"

	#name and build image in SOURCE_DIR and tag builded image
	#use no cache, we want all to be fresh when deploying
	docker build -t $NEW_IMAGE_NAME -f "$DOC_DOCKERFILE_PROD" --no-cache . >&2 &&
#	docker tag "$NEW_IMAGE_NAME" "$DOC_REPO/$NEW_IMAGE_NAME" >&2

	if [ $? -eq 0 ]; then
		sed -i "s|\(.*image:\s*$DOC_REPO/$IMAGE_NAME:\)$CUR_VERSION|\1$NEW_VERSION|g" "$DOCKER_COMPOSE_FILE"
		info "new version build: $(get_current_version $IMAGE_NAME)"
	else
		exit 1;
	fi
}

dockerbuild() {
	docker-compose -f $DOCKER_COMPOSE_FILE -f $DOCKER_COMPOSE_LOCAL_FILE build $@
#    docker build --no-cache -t "$1" "$SOURCE_DIR"
}

dockerup() {
	case "$1" in
		"local") out "building for local";
			if [ ! -f "$DOCKER_COMPOSE_LOCAL_FILE" ]; then
				errout "no configuration file found in current dir ($DOCKER_COMPOSE_LOCAL_FILE)"
			fi
			shift
			docker-compose -f "$DOCKER_COMPOSE_FILE" -f "$DOCKER_COMPOSE_LOCAL_FILE" up -d $@
		;;
		"prod") out "building for prod";
			docker-compose up
			;;
		"whats") showhelp ;;
		*) out "wrong env, please use 'local' or 'prod'"; exit 1; ;;
	esac
}

dockerdown() {
    out "Stopping and remove all containers"
    docker-compose down $@
}

dockerstop() {
    out "Stopping all containers"
    docker-compose stop $@
}

dockerip() {
	CONTAINER_ID="$1"
	echo $(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' ${CONTAINER_ID})
}

dockerlogs() {
	docker-compose -f "$DOCKER_COMPOSE_FILE" -f "$DOCKER_COMPOSE_LOCAL_FILE" logs -f $@
}

initproject() {
	DOC_PROJECT_NAME=$1
	GIT_REPO=$2
	initsettings "$DOC_PROJECT_NAME"

	if [ -z "$DOC_PROJECT_NAME" ]; then
		errout "no project name given"
		exit 1
	fi
	
	if [ -z "$DOC_USERNAME" ]; then
		errout "please set a username or company name in DOC_USERNAME"
		exit 1
	fi
	
	info "init project \"$DOC_FULL_NAME\""
	initdockerfiles

	#initialize all deps before start building
	if [ -f "scripts/init.sh" ]; then
	    info "run init.sh"
	    scripts/init.sh ${GIT_REPO}
	fi

	info "start building project"
	dockerup local &&
		info "===========\n$DOC_FULL_NAME was built successfully\n\n"

	if [ -n ${NGINX_CONTAINER} ]; then
		NGINX_IP=$(dockerip "nginx")
		out "please add $NGINX_IP to your /etc/hosts or run this:"
		out "echo -e \"$NGINX_IP\\\t${DOC_PROJECT_NAME}.dmk\" | sudo tee --append /etc/hosts"
	else
		WEB_IP=$(dockerip "${DOC_PROJECT_NAME}_web_local")
		out "please add IP $WEB_IP to your /etc/hosts or run this:"
		out "echo -e \"$WEB_IP\\\t${DOC_PROJECT_NAME}.dmk\" | sudo tee --append /etc/hosts"
	fi
}

initsettings() {
	if [ ! -f "$DOC_SETTINGS" ]; then
		touch "$DOC_SETTINGS"
	fi
	source "$DOC_SETTINGS"

	DOC_PROJECT_NAME="$1"

	if [ -z "$DOC_USERNAME" ]; then
		while [ -z "$DOC_USERNAME" ]; do
			ask "user / company name? [DOC_USERNAME]"
			read DOC_USERNAME
		done

		ask "docker regestry server (repo.domain.de:5000)? [DOC_REPO]"
		read DOC_REPO

		if [ -n "$DOC_REPO" ]; then
			DOC_USERNAME="$DOC_REPO\$DOC_USERNAME"
		fi
		echo "DOC_USERNAME=\"$DOC_USERNAME\"" >> "$DOC_SETTINGS"
	fi

	if [ -z "$DOC_PROJECT_NAME" ] || [ -z "$DOC_FULL_NAME" ]; then
		while [ -z "$DOC_PROJECT_NAME" ]; do
			ask "project name? [DOC_PROJECT_NAME]"
			read DOC_PROJECT_NAME
		done
		echo "DOC_PROJECT_NAME=\"$DOC_PROJECT_NAME\"" >> "$DOC_SETTINGS"
		DOC_FULL_NAME="$DOC_USERNAME/$DOC_PROJECT_NAME"
		echo "DOC_FULL_NAME=\"$DOC_FULL_NAME\"" >> "$DOC_SETTINGS"
	fi

	if [ -z "$DOC_GITHUB_OAUTH" ]; then
		while [ -z "$DOC_GITHUB_OAUTH" ]; do
			ask "github oauth token? [DOC_GITHUB_OAUTH]"
			read DOC_GITHUB_OAUTH
		done
		echo "DOC_GITHUB_OAUTH=\"$DOC_GITHUB_OAUTH\"" >> "$DOC_SETTINGS"
	fi

	if [ -z "$DOC_SSH_KEY_FILE" ]; then
		while [ -z "$DOC_SSH_KEY_FILE" ]; do
			ask "path to ssh key file? [DOC_SSH_KEY_FILE]"
			read DOC_SSH_KEY_FILE
		done
		echo "DOC_SSH_KEY_FILE=\"$DOC_SSH_KEY_FILE\"" >> "$DOC_SETTINGS"
	fi

	if [ -z "$HOST_USER" ]; then
		while [ -z "$HOST_USER" ]; do
			ask "username for shared source dir (aka your username)? [HOST_USER]"
			read HOST_USER
		done
		HOST_USERID=$(id -u ${HOST_USER})
		if [ ${HOST_USERID} -le 0  ]; then
			errout "user $HOST_USER does not exists"
		fi
		echo "HOST_USER=\"$HOST_USER\"" >> "$DOC_SETTINGS"
		echo "HOST_USERID=$HOST_USERID" >> "$DOC_SETTINGS"
	fi

	if [ -z "$HOST_GROUP" ]; then
		while [ -z "$HOST_GROUP" ]; do
			ask "usergroup for shared source dir (aka your usergroup)? [HOST_GROUP]"
			read HOST_GROUP
		done
		HOST_GROUPID=$(id -g ${HOST_USER})
		if [ ${HOST_GROUPID} -le 0 ]; then
			errout "user $HOST_GROUP does not exists"
		fi
		echo "HOST_GROUP=\"$HOST_GROUP\"" >> "$DOC_SETTINGS"
		echo "HOST_GROUPID=$HOST_GROUPID" >> "$DOC_SETTINGS"
	fi

	source "$DOC_SETTINGS"
	export DOC_SETTINGS
}

initdockerfiles() {
	cp ./template/docker-compose* .
	cp ./template/Dockerfile* dockerfiles/
	cp ./template/apache-vhost.conf ${DOC_VHOST_CONFIG}

	for file in "$DOCKER_COMPOSE_FILE" "$DOCKER_COMPOSE_LOCAL_FILE" \
		"$DOCKER_COMPOSE_TEST_FILE" "$DOCKER_COMPOSE_BETA_FILE" \
		"$DOCKER_COMPOSE_PROD_FILE" "$DOC_DOCKERFILE_INSTALL" \
		"$DOC_DOCKERFILE_PROD" "$DOC_VHOST_CONFIG"; do
		if [ -w "$file" ]; then
			sed -i "s|###projectname###|$DOC_PROJECT_NAME|g" "$file"
			sed -i "s|###username###|$DOC_USERNAME|g" "$file"
			sed -i "s|###repohost###|$DOC_REPO|g" "$file"
			sed -i "s|###github_oauth###|$DOC_GITHUB_OAUTH|g" "$file"
			sed -i "s|###ssh_key_file###|$DOC_SSH_KEY_FILE|g" "$file"
			sed -i "s|###ssh_auth_sock###|$SSH_AUTH_SOCK|g" "$file"
			sed -i "s|###hostuser###|$HOST_USER|g" "$file"
			sed -i "s|###hostuserid###|$HOST_USERID|g" "$file"
			sed -i "s|###hostgroup###|$HOST_GROUP|g" "$file"
			sed -i "s|###hostgroupid###|$HOST_GROUPID|g" "$file"
		else
			warnout "file "$file" is missing"
		fi
	done
}

dockerin() {
	WEB_CONTAINER=$(docker ps -f name=_web -q -l)
	info $(docker inspect --format 'Name: {{.Name}} erstellt: {{.Created}}' "$WEB_CONTAINER")
	docker exec -ti "$WEB_CONTAINER" bash
}


### Helper Methods

increment_version (){
  declare -a part=( ${1//\./ } )
  declare    new
  declare -i carry=1

  for (( CNTR=${#part[@]}-1; CNTR>=0; CNTR-=1 )); do
    len=${#part[CNTR]}
    new=$((part[CNTR]+carry))
    [ ${#new} -gt $len ] && carry=1 || carry=0
    [ $CNTR -gt 0 ] && part[CNTR]=${new: -len} || part[CNTR]=${new}
  done
  new="${part[*]}"
  echo -e "${new// /.}"
}

self_update() {
	DOC_DIR="`dirname $(realpath $(which doc))`/.."
	if [ -d ${DOC_DIR} ]; then
		info "updating doc..."
		cd ${DOC_DIR}
		git pull
		showhelp
		info "...done"
	else
		errout "could not find doc dir"
	fi
}

RED='\033[0;31m'
YELLOW='\033[1;33m'
ORANGE='\033[0;33m'
NC='\033[0m' # No Color
	
out() {
	echo -e "$@"
}

info() {
	out "${YELLOW}$@${NC}"
}

errout() {
	echo -e "${RED}[ERROR]: $@${NC}"
	exit 1;
}

warnout() {
	echo -e "${ORANGE}[WARNING]: $@${NC}"
}

ask() {
	echo -n -e "${YELLOW}$@${NC} "
}

if [ -f "$DOC_SETTINGS" ]; then
    source "$DOC_SETTINGS"
    export DOC_SETTINGS
fi

### Main
case "$1" in
	"build") out "building image"; shift; dockerbuild $@ ;;
	"tag") out "build and tag"; buildandtag $2 $(get_current_version $2) ;;
	"up") out "docker up"; dockerup "$2" ;;
	"down") out "docker down"; shift; dockerdown $@ ;;
	"stop") out "docker stop"; shift; dockerstop $@ ;;
	"in") out "try to find a container and start a bash..."; dockerin ;;
	"deploy") out "starting deployment"; dockerdeploy "$2" "$3" ;;
	"initproject") shift; initproject $@ ;;
	"logs") shift; dockerlogs $@ ;;
	"reinit") shift; out "reinit all Dockerfiles"; initsettings $@ && initdockerfiles ;;
	"self-update") self_update ;;
	*)   out "Unknown parameter"; showhelp; ;;
esac
